// @ts-nocheck

/**
 * Capa Frida Complete Monitor Script
 * Generated by hook_builder.py
 */

console.log("[+] Capa Frida Java Monitor initializing...");

// TODO: Should we use timestamp in filename for multiple runs? and let user specify output path via command line?
// var timestamp = Date.now(); 

// "/frida_outputs" must be created on the device with write permissions,
// "{{jsonl_filename}}" is set via the 'hook_builder.py' command-line arguments.
var filePath = "/data/local/tmp/frida_outputs/{{jsonl_filename}}";
// "/data/local/tmp/frida_outputs/frida_" + timestamp + ".json";

var outputFile: File | null = null;
var recordId = 0;
var callId = 0;

// Using string template to avoid IDE syntax errors
// hashesData contains double quotes in JSON format, so we use single quotes here
var hashesData = '{{ hashes }}';
var packageName = "{{ package_name }}";

var allMetadata = {
    hashes: JSON.parse(hashesData),
    package_name: packageName,
    process_id: Process.id,
    arch: Process.arch,
    platform: Process.platform
};

try {
    outputFile = new File(filePath, "w");
} catch (e: any) {
    console.log("[ERROR] Failed to open file: " + e);
}

function writeRecord(record: object) {
    if (outputFile) {
        outputFile.write(JSON.stringify(record) + '\n');
        outputFile.flush();
        return true;
    }
    return false;
}

function recordMetadata() {
    var record = {
        "id": recordId++,
        "metadata": allMetadata
    };

    if (writeRecord(record)) {
        console.log("[+] Metadata written")
    }
}

function recordApiCall(apiName: string, argumentsList: any[], apiType: string) {
    var apiCallRecord = {
        "process_id": Process.id,
        "thread_id": Process.getCurrentThreadId(),
        "call_id": callId++,
        "api_name": apiName,
        "arguments": argumentsList || []
    };
    
    var record = {
        "id": recordId++,
        "api": {}
    };
    
    (record as any).api[apiType] = apiCallRecord;
    
    if (writeRecord(record)) {
        console.log("[+] " + apiType + " call written: " + apiName);
    }
}

function processValue(arg: any): any {
    if (arg === null || typeof arg === 'undefined') {
        return null;
    }
    
    if (typeof arg === 'string' || typeof arg === 'number' || typeof arg === 'boolean') {
        return arg;
    }

    // Handle Frida-wrapped Java objects
    if (typeof arg === 'object' && arg.$className) {
        return arg.toString();
    }

    // Handle arrays and other objects with toString()
    // Note: JavaScript objects may become "[object Object]",
    // beacause non-overridden Object.prototype.toString() returns type info, not content
    return arg.toString();
}

function parseNativeValue(arg: any, argType: any): any {
    if (arg.isNull()) {
        return null;
    }
    
    switch (argType) {
        case 'int':
            return arg.toInt32();
        case 'uint':
            return arg.toUInt32();
        case 'bool':
            return arg.toInt32() !== 0;

        case 'char*':
        case 'const char*':
            try {
                var str = arg.readUtf8String();
                return str !== null ? str : arg.toString();
            } catch (e: any) {
                return arg.toString();
            }
        
        default:
            return arg.toString();
    }
}

recordMetadata();

// Generated Native hooks content
{{native_hooks_content}}

Java.perform(function() {
    console.log("[+] Capa Frida Java Monitor started");
    // Generated Java hooks content
    {{ java_hooks_content | indent(4) }} 

});