/**
 * Capa Frida Complete Monitor Script
 * Generated by hook_builder.py
 */

console.log("[+] Capa Frida Java Monitor initializing...");

// TODO: Should we use timestamp in filename for multiple runs? and let user specify output path via command line?
var timestamp = Date.now(); 

// "/frida_output" must be created on the device with write permissions,
// "api_calls.jsonl" is set via the 'hook_builder.py' command-line arguments.
var filePath = "/data/local/tmp/frida_output/api_calls.jsonl";
// "/data/local/tmp/frida_output/frida_" + timestamp + ".json";

var outputFile = null;
var recordId = 0;
var allMetadata = {};

try {
    outputFile = new File(filePath, "w");
} catch (e) {
    console.log("[ERROR] Failed to open file: " + e);
}

function writeRecord(record) {
    if (outputFile) {
        outputFile.write(JSON.stringify(record) + '\n');
        outputFile.flush();
        return true;
    }
    return false;
}

function writeMetadata() {
    var record = {
        "id": recordId++,
        "metadata": allMetadata
    };

    if (writeRecord(record)) {
        console.log("[+] Metadata written")
    }
}

function collectBasicInfo() {
    allMetadata.process_id = Process.id;
    allMetadata.arch = Process.arch;
    allMetadata.platform = Process.platform;
    console.log("[+] Basic info collected");
}

collectBasicInfo();

var call_id = 0;

function recordApiCall(apiName, argumentsList, apiType) {
    var apiCallRecord = {
        "process_id": Process.id,
        "thread_id": Process.getCurrentThreadId(),
        "call_id": call_id++,
        "api_name": apiName,
        "arguments": argumentsList || []
    };
    
    var record = {
        "id": recordId++,
        "api": {}
    };
    
    record.api[apiType] = apiCallRecord;
    
    if (writeRecord(record)) {
        console.log("[+] " + apiType + " call written: " + apiName);
    }
}

function processValue(arg) {
    if (arg === null || typeof arg === 'undefined') {
        return null;
    }
    
    if (typeof arg === 'string' || typeof arg === 'number' || typeof arg === 'boolean') {
        return arg;
    }

    // Handle Frida-wrapped Java objects
    if (typeof arg === 'object' && arg.$className) {
        return arg.toString();
    }

    // Handle arrays and other objects with toString()
    // Note: JavaScript objects may become "[object Object]",
    // beacause non-overridden Object.prototype.toString() returns type info, not content
    return arg.toString();
}

function parseNativeValue(arg, argType) {
    if (arg.isNull()) {
        return null;
    }
    
    switch (argType) {
        case 'int':
            return arg.toInt32();
        case 'uint':
            return arg.toUInt32();
        case 'bool':
            return arg.toInt32() !== 0;

        case 'char*':
        case 'const char*':
            try {
                var str = arg.readUtf8String();
                return str !== null ? str : arg.toString();
            } catch (e) {
                return arg.toString();
            }
        
        default:
            return arg.toString();
    }
}

// Generated Native hooks content
try {
    var libc_so = Process.getModuleByName('libc.so');
    var open_addr = libc_so.getExportByName('open');
    Interceptor.attach(open_addr, {
        onEnter: function(args) {
            var arguments_list = [];
            
            
            arguments_list.push({
                name: 'arg0',
                value: parseNativeValue(args[0], 'char*')
            });
            
            arguments_list.push({
                name: 'arg1',
                value: parseNativeValue(args[1], 'int')
            });
            
            
            recordApiCall('libc.so.open', arguments_list, "native_api");
        }
    });
} catch (e) {
    console.log('[ERROR] Failed to hook native function libc.so.open: ' + e.message);
}

try {
    var libc_so = Process.getModuleByName('libc.so');
    var execve_addr = libc_so.getExportByName('execve');
    Interceptor.attach(execve_addr, {
        onEnter: function(args) {
            var arguments_list = [];
            
            recordApiCall('libc.so.execve', arguments_list, "native_api");
        }
    });
} catch (e) {
    console.log('[ERROR] Failed to hook native function libc.so.execve: ' + e.message);
}

Java.perform(function() {
    console.log("[+] Capa Frida Java Monitor started");

    // Debug found ActivityThread.currentApplication() available after 1 second, returns null otherwise
    // but this doesn't guarantee metadata will be written as first line in JSON.
    // Current approach can ensure each script reinjection maintains complete metadata without requiring device restart
    setTimeout(function() {
    
        var ActivityThread = Java.use("android.app.ActivityThread");
        var currentApp = ActivityThread.currentApplication();
        
        if (currentApp && currentApp.getPackageName) {
            allMetadata.package_name = currentApp.getPackageName().toString();
            console.log("[+] Package name: " + allMetadata.package_name);
        } else {
            console.log("[!] Could not get package name, using fallback");
            allMetadata.package_name = "unknown_package";
        }
        
        writeMetadata();
    }, 1000);

    // Generated Java hooks content
    try {
        var File = Java.use('java.io.File');
        File.$init.overloads.forEach(function(overload) {
            overload.implementation = function() {
                var args = [];
                
                recordApiCall('java.io.File.<init>', args, "java_api");
                return this.$init.apply(this, arguments);
            };
        });
    } catch (e) {
        console.log('[ERROR] Failed to hook java.io.File.<init>: ' + e.message);
    }

    try {
        var SystemProperties = Java.use('android.os.SystemProperties');
        SystemProperties.get.overloads.forEach(function(overload) {
            overload.implementation = function() {
                var args = [];
                
                
                var result = SystemProperties.get.apply(SystemProperties, arguments);
                
                recordApiCall('android.os.SystemProperties.get', args, "java_api");
                return result;
            };
        });
    } catch (e) {
        console.log('[ERROR] Failed to hook Java static method android.os.SystemProperties.get: ' + e.message);
    }

    try {
        var RootBeerNative = Java.use('com.scottyab.rootbeer.RootBeerNative');
        RootBeerNative.checkForRoot.overloads.forEach(function(overload) {
            overload.implementation = function() {
                var args = [];
                
                
                var result = this.checkForRoot.apply(this, arguments);
                
                recordApiCall('com.scottyab.rootbeer.RootBeerNative.checkForRoot', args, "java_api");
                return result;
            };
        });
    } catch (e) {
        console.log('[ERROR] Failed to hook Java native method com.scottyab.rootbeer.RootBeerNative.checkForRoot: ' + e.message);
    } 

});